const 哎呀呀这是我的ID啊 = "8705800f-adf3-4cf0-91a1-3b6ab77c9466"; //与主worker的ID需保持一致
import { connect } from 'cloudflare:sockets';
export default {
  async fetch(访问请求) {
    const 验证安全密钥 = 访问请求.headers.get('safe-key');
    if (验证安全密钥 === 哎呀呀这是我的ID啊) {
      const 接收地址类型String = 访问请求.headers.get('dizhi');
      识别地址类型 = parseInt(接收地址类型String, 10);
      访问地址 = 访问请求.headers.get('hostname');
      const 接收访问端口String = 访问请求.headers.get('port');
      访问端口 = parseInt(接收访问端口String, 10);
      const 接收初始数据 = 访问请求.headers.get('tcphand');
      const 解码初始数据 = atob(接收初始数据);
      初始握手数据 = Uint8Array.from(解码初始数据, c => c.charCodeAt(0));
      const 启用反代功能String = 访问请求.headers.get('proxyip-open');
      启用反代功能 = 启用反代功能String === 'true';
      const 启用NAT64反代功能String = 访问请求.headers.get('nat64-open');
      启用NAT64反代 = 启用NAT64反代功能String === 'true';
      const 启用NAT64全局反代String = 访问请求.headers.get('nat64-global');
      启用NAT64全局反代 = 启用NAT64全局反代String === 'true';
      const 启用SOCKS5反代String = 访问请求.headers.get('socks5-open');
      启用SOCKS5反代 = 启用SOCKS5反代String === 'true';
      const 启用SOCKS5全局反代String = 访问请求.headers.get('socks5-global');
      启用SOCKS5全局反代 = 启用SOCKS5全局反代String === 'true';
      反代IP = 访问请求.headers.get('proxyip');
      我的NAT64地址 = 访问请求.headers.get('nat64');
      我的SOCKS5账号 = 访问请求.headers.get('socks5');
      const 启用新版传输模式String = 访问请求.headers.get('queue');
      启用新版传输模式 = 启用新版传输模式String === 'true';
      const 启动控流机制String = 访问请求.headers.get('kongliu-open');
      启动控流机制 = 启动控流机制String === 'true';
      const 传输控流延迟String = 访问请求.headers.get('kongliu-time');
      传输控流延迟 = parseInt(传输控流延迟String, 10);
      return await 升级WS请求();
    } else {
    return new Response('Forbidden', { status: 403 });
    }
  }
};
let 识别地址类型, 访问地址, 访问端口, 初始握手数据, 启用反代功能, 反代IP, 启用NAT64反代, 我的NAT64地址, 启用NAT64全局反代, 启用SOCKS5反代, 启用SOCKS5全局反代, 我的SOCKS5账号, 启用新版传输模式, 启动控流机制, 传输控流延迟;
////////////////////////////////////////////////////////////////////////脚本主要架构//////////////////////////////////////////////////////////////////////
async function 升级WS请求() {
  const 创建WS接口 = new WebSocketPair();
  const [客户端, WS接口] = Object.values(创建WS接口);
  WS接口.accept();
  WS接口.send(new Uint8Array([0, 0]));
  await 创建TCP握手(WS接口);
  return new Response(null, { status: 101, webSocket: 客户端 }); //一切准备就绪后，回复客户端WS连接升级成功
}
async function 创建TCP握手(WS接口, TCP接口) {
  console.log(`访问地址类型为: ${识别地址类型}，访问地址: ${访问地址}，访问端口: ${访问端口}`);
  try {
    if (启用反代功能 && 启用NAT64反代 && 启用NAT64全局反代 && 识别地址类型 === 1) {
      const [NAT64地址, NAT64端口] = 解析地址端口(我的NAT64地址);
      const 转换NAT64地址 = NAT64地址.slice(1, -1)
      const 拼接NAT64地址 = `[${转换NAT64地址}${访问地址.split('.').map(n=>(+n).toString(16).padStart(2,'0')).join('').replace(/(.{4})/, '$1:')}]`;
      TCP接口 = connect({ hostname: 拼接NAT64地址, port: NAT64端口 });
    } else {
      if (启用反代功能 && 启用SOCKS5反代 && 启用SOCKS5全局反代) {
        TCP接口 = await 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口);
      } else {
        try {
          if (识别地址类型 === 3) {
            const 转换IPV6地址 = `[${访问地址}]`
            TCP接口 = connect({ hostname: 转换IPV6地址, port: 访问端口 });
          } else {
            TCP接口 = connect({ hostname: 访问地址, port: 访问端口 });
          }
          await TCP接口.opened;
        } catch {
          if (启用反代功能) {
            if (启用NAT64反代 && 识别地址类型 === 1) {
              const [NAT64地址, NAT64端口] = 解析地址端口(我的NAT64地址);
              const 转换NAT64地址 = NAT64地址.slice(1, -1)
              const 拼接NAT64地址 = `[${转换NAT64地址}${访问地址.split('.').map(n=>(+n).toString(16).padStart(2,'0')).join('').replace(/(.{4})/, '$1:')}]`;
              TCP接口 = connect({ hostname: 拼接NAT64地址, port: NAT64端口 });
            } else if (启用SOCKS5反代) {
              TCP接口 = await 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口);
            } else {
              let [反代IP地址, 反代IP端口] = 解析地址端口(反代IP);
              TCP接口 = connect({ hostname: 反代IP地址, port: 反代IP端口});
            }
          }
        }
      }
    }
    await TCP接口.opened;
    const 传输数据 = TCP接口.writable.getWriter();
    if (初始握手数据.length > 0) {
      await 传输数据.write(初始握手数据);
    } else {
      console.log(`${访问地址}没有初始数据`);
    }
    if (启用新版传输模式) {
      const 读取数据 = TCP接口.readable.getReader();
      队列传输管道(访问地址, 传输数据, 读取数据, WS接口); //建立WS接口与TCP接口的传输管道
    } else {
      原始传输管道(传输数据, TCP接口, WS接口)
    }
  } catch (e) {
    console.log(`${访问地址}连接握手失败: ${e}`);
    return new Response(`连接握手失败: ${e}`, { status: 500 });
  }
}
//第三步，创建客户端WS-CF-目标的传输通道并监听状态
async function 原始传输管道(传输数据, TCP接口, WS接口) {
  WS接口.addEventListener('message', async event => { try { await 传输数据.write(new Uint8Array(event.data)) } catch {}; }); //监听客户端WS接口后续数据，推送给TCP接口
  TCP接口.readable.pipeTo(new WritableStream({ async write(返回数据) { WS接口.send(返回数据) } })); //将TCP接口返回的数据回写至客户端WS接口
}
async function 队列传输管道(访问地址, 传输数据, 读取数据, WS接口, 传输队列 = Promise.resolve(), 开始传输时间 = performance.now(), 字节计数 = 0, 累计传输字节数 = 0, 大数据包 = false, 已结束 = false) {
  WS接口.addEventListener('message', event => 传输队列 = 传输队列.then(async () => {
    let 分段初值 = 0
    let 分段大小 = 4*1024;
    const WS数据 = new Uint8Array(event.data);
    while (分段初值 < WS数据.length) {
      const 数据块 = WS数据.slice(分段初值, 分段初值 + 分段大小);
      try { await 传输数据.write(数据块) } catch {};
      累计传输字节数 += 数据块.length;
      分段初值 += 分段大小;
    }
    累计传输字节数 += WS数据.length;
  }).catch());
  const 保活 = setInterval(async () => {
    if (已结束) {
      clearInterval(保活);
    } else {
      传输队列 = 传输队列.then(async () => await 传输数据.write(new Uint8Array(0))).catch();
    }
  }, 30000);
  while (true) {
    const { done: 流结束, value: 返回数据 } = await 读取数据.read();
    if (返回数据 && 返回数据.length > 0) {
      if (!大数据包 && 返回数据.length >= 4096) {
        let TCP缓存 = [];
        let TCP缓存长度 = 0;
        大数据包 = true;
        TCP缓存.push(返回数据);
        TCP缓存长度 += 返回数据.length;
        while (true) {
          const { done: 流结束, value: 返回数据 } = await 读取数据.read();
          if (流结束) 已结束 = true;
          if (返回数据 && 返回数据.length > 0) {
            TCP缓存.push(返回数据);
            TCP缓存长度 += 返回数据.length;
            if (返回数据.length < 4096 || TCP缓存长度 >= 512*1024) {
              let 合并偏移 = 0;
              let 待推送数据 = new Uint8Array(TCP缓存长度);
              for (const 数据块 of TCP缓存) {
                待推送数据.set(数据块, 合并偏移);
                合并偏移 += 数据块.length;
              }
              传输队列 = 传输队列.then(() => WS接口.send(待推送数据)).catch();
              累计传输字节数 += 待推送数据.length;
              大数据包 = false;
              break;
            }
          }
        }
      } else {
        传输队列 = 传输队列.then(() => WS接口.send(返回数据)).catch();
        累计传输字节数 += 返回数据.length;
      }
      if (启动控流机制 && (累计传输字节数 - 字节计数) > 2*1024*1024) {
        传输队列 = 传输队列.then(async () => await new Promise(resolve => setTimeout(resolve, 传输控流延迟))).catch();
        字节计数 = 累计传输字节数;
      }
    }
    if (流结束 || 已结束) { 已结束 = true; break; }
  }
  console.log(`${访问地址}传输完毕，总传输数据: ${格式化字节(累计传输字节数)}，总传输时间: ${格式化时间(performance.now() - 开始传输时间)}`);
}
function 格式化字节(数据字节, 保留位数 = 2) {
  const 单位 = ['B', 'KB', 'MB', 'GB', 'TB'];
  let 指数 = 0;
  let 数值 = 数据字节;
  while (数值 >= 1024 && 指数 < 单位.length - 1) {
    数值 /= 1024;
    指数++;
  }
  return `${数值.toFixed(保留位数)} ${单位[指数]}`;
}
function 格式化时间(毫秒数) {
  const 总毫秒 = 毫秒数;
  const 小时 = Math.floor(总毫秒 / (3600 * 1000));
  const 分钟 = Math.floor((总毫秒 % (3600 * 1000)) / (60 * 1000));
  const 秒 = Math.floor((总毫秒 % (60 * 1000)) / 1000);
  const 毫秒 = 总毫秒 % 1000;
  return `${小时.toString().padStart(2, '0')}:${分钟.toString().padStart(2, '0')}:${秒.toString().padStart(2, '0')}.${毫秒.toString().padStart(3, '0')}`;
}
//////////////////////////////////////////////////////////////////////////SOCKS5部分//////////////////////////////////////////////////////////////////////
async function 创建SOCKS5接口(识别地址类型, 访问地址, 访问端口, 转换访问地址, 传输数据, 读取数据) {
  let SOCKS5接口, 账号, 密码, 地址, 端口;
  let 索引SOCKS5账号 = 0;
  我的SOCKS5账号 = Array.isArray(我的SOCKS5账号) ? 我的SOCKS5账号 : [我的SOCKS5账号];
  while (索引SOCKS5账号 < 我的SOCKS5账号.length) {
    const 提取SOCKS5账号 = 我的SOCKS5账号[索引SOCKS5账号]
    try {
      ({ 账号, 密码, 地址, 端口 } = await 获取SOCKS5账号(提取SOCKS5账号));
      SOCKS5接口 = connect({ hostname: 地址, port: 端口 });
      await SOCKS5接口.opened;
      传输数据 = SOCKS5接口.writable.getWriter();
      读取数据 = SOCKS5接口.readable.getReader();
      const 转换数组 = new TextEncoder(); //把文本内容转换为字节数组，如账号，密码，域名，方便与S5建立连接
      const 构建S5认证 = new Uint8Array([5, 2, 0, 2]); //构建认证信息,支持无认证和用户名/密码认证
      await 传输数据.write(构建S5认证); //发送认证信息，确认目标是否需要用户名密码认证
      const 读取认证要求 = (await 读取数据.read()).value;
      if (读取认证要求[1] === 0x02) { //检查是否需要用户名/密码认证
        if (!账号 || !密码) {
          throw new Error (`未配置账号密码`);
        }
        const 构建账号密码包 = new Uint8Array([ 1, 账号.length, ...转换数组.encode(账号), 密码.length, ...转换数组.encode(密码) ]); //构建账号密码数据包，把字符转换为字节数组
        await 传输数据.write(构建账号密码包); //发送账号密码认证信息
        const 读取账号密码认证结果 = (await 读取数据.read()).value;
        if (读取账号密码认证结果[0] !== 0x01 || 读取账号密码认证结果[1] !== 0x00) { //检查账号密码认证结果，认证失败则退出
          throw new Error (`账号密码错误`);
        }
      }
      switch (识别地址类型) {
        case 1: // IPv4
          转换访问地址 = new Uint8Array( [1, ...访问地址.split('.').map(Number)] );
          break;
        case 2: // 域名
          转换访问地址 = new Uint8Array( [3, 访问地址.length, ...转换数组.encode(访问地址)] );
          break;
        case 3: // IPv6
          转换访问地址 = 转换为Socks5IPv6地址(访问地址);
          function 转换为Socks5IPv6地址(原始地址) {
            const 去括号地址 = 原始地址.startsWith('[') && 原始地址.endsWith(']')
              ? 原始地址.slice(1, -1)
              : 原始地址;
            const 分段 = 去括号地址.split('::');
            const 前缀 = 分段[0] ? 分段[0].split(':').filter(Boolean) : [];
            const 后缀 = 分段[1] ? 分段[1].split(':').filter(Boolean) : [];
            const 填充数量 = 8 - (前缀.length + 后缀.length);
            if (填充数量 < 0) throw new Error('IPv6地址格式错误');
            const 完整分段 = [...前缀, ...Array(填充数量).fill('0'), ...后缀];
            const IPv6字节 = 完整分段.flatMap(字段 => {
              const 数值 = parseInt(字段 || '0', 16);
              return [(数值 >> 8) & 0xff, 数值 & 0xff];
            });
            return new Uint8Array([0x04, ...IPv6字节]);
          }
          break;
      }
      const 构建转换后的访问地址 = new Uint8Array([ 5, 1, 0, ...转换访问地址, 访问端口 >> 8, 访问端口 & 0xff ]); //构建转换好的地址消息
      await 传输数据.write(构建转换后的访问地址); //发送转换后的地址
      const 检查返回响应 = (await 读取数据.read()).value;
      if (检查返回响应[0] !== 0x05 || 检查返回响应[1] !== 0x00) {
        throw new Error (`目标地址连接失败，访问地址: ${访问地址}，地址类型: ${识别地址类型}`);
      }
      传输数据.releaseLock();
      读取数据.releaseLock();
      return SOCKS5接口;
    } catch {
      索引SOCKS5账号++
    };
  }
  传输数据?.releaseLock();
  读取数据?.releaseLock();
  await SOCKS5接口?.close();
  throw new Error (`所有SOCKS5账号失效`);
}
async function 获取SOCKS5账号(SOCKS5) {
  const 分隔账号 = SOCKS5.includes("@") ? SOCKS5.lastIndexOf("@") : -1;
  const 账号段 = SOCKS5.slice(0, 分隔账号);
  const 地址段 = 分隔账号 !== -1 ? SOCKS5.slice(分隔账号 + 1) : SOCKS5;
  const [账号, 密码] = [账号段.slice(0, 账号段.lastIndexOf(":")), 账号段.slice(账号段.lastIndexOf(":") + 1)];
  const [地址, 端口] = 解析地址端口(地址段);
  return { 账号, 密码, 地址, 端口 };
}
function 解析地址端口(地址段) {
  let 地址, IPV6地址, 端口;
  if (地址段.startsWith('[')) {
    [IPV6地址, 端口 = 443] = 地址段.slice(1, -1).split(']:');
    地址 = `[${IPV6地址}]`
  } else {
    [地址, 端口 = 443] = 地址段.split(':')
  }
  return [地址, 端口];
}
